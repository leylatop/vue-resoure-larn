1. packages中 private 标识该模块为私有包

2. packages中 workspaces 标识该工作空间，管理的包放置的位置

3. 管理的包的入口要统一

4. 管理的包的package.json  main和 module 的区别
- main 指向的文件是给node的common.js使用的（require）
- module 指向的文件是给es6和webpack使用的（import）

cjs 代表node模块（commonjs）
esm-bundler 代表es6模块（es module）

5. formats 打包的类型
6. 自定义的buildOptions是给rollup打包时使用的
7. rollup和webpack的区别：
- rollup



- reactive 响应式方法

8. 在根目录下执行 yarn install，将会把packages文件下所有的模块的目录，都放到根目录的node modules，自动产生软链，链到真正的packages文件夹下，这样就可以相互引用，实现共享
- yarn install 会去package.json找workspaces


9. ref和reactive的区别
- reactive定义复杂数据类型的响应式数据，内部采用的是proxy代理
- ref定义基本数据类型的响应式数据，内部采用的是Object.defineProperty（主要是因为proxy不能代理基本数据类型）

10. vue源码，基本上都是高阶函数，做了类似柯里化的功能

11. api解释
- 定义响应式对象：reactive ->proxy
- 定义响应式基本数据：ref ->defineProptery
- 解构reactive：toRefs（解构多个属性-> 循环调用toRef），toRef（解构其中一个属性-> 触发原对象的set和get）
- 更新： effect（track、trigger）

12. git clone --depth 1

13. index.ts 对外暴露一些方法，方便外界使用

14. toRaw方法用来把proxy转回object

15. markRow 方法给对象添加一个__v_skip属性，表示该对象不可以被代理，内部原理使用的是Object.defineProperty

16. 面试题
- reactive
    - 判断是否是对象
    - 重复代理的情况
    - 判断不同类型，对不同类型进行proxy
    - 使用map对proxy做缓存

- get（baseHandler）
    - 对数组类型单独处理
    - 对ref进行处理

- set （baseHandler）
    - 对ref进行处理
    - 对新增和修改做不同处理

-track
    - 维护target、属性和effect之间的对应关系

- trigger
    - 找到target中，属性对应的effect列表，依次执行

- 响应式原理：
- 属性会收集effect，属性更新会让收集的effect重新执行


